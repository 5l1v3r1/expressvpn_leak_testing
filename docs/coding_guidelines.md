# Python 2.7 vs 3

We have chosen to use python 3. Python 3 is being ever more widely adopted and Python 2 will be
retired by 2020. Most Python 2 libraries are available for Python 3 and so we don't envisage any
practical issues with using Python 3. If you try to use Python 2 with this codebase then it will
undoubtedly fail!

# Coding Standards

We generally try to follow PEP 8 and validate/enforce that using pylint. Exceptions to the default
for PEP 8, i.e. the default config generated by pylint, are below. Manual exceptions are sometimes
made. In general the reasons should be clear but if not, the exceptions should always come with a
comment explaining why.

## Exceptions to PEP 8

#### Long lines

We conform to line lengths of 100 characters (note PEP 8 is 80 characters) except for import lines.
Wrapping import lines for the purpose of avoiding long lines is ugly and actually degrades
readability, they are thus allowed. This includes both lines starting with `import` and lines
starting with `from`.

#### `invalid-name`

We allow function and method names longer than 20 characters (currently up to 50). We believe that
it's beneficial to allow longer, descriptive names for this type of project.

We allow `id` to be a valid attribute name.

#### `len-as-condition`

We disagree with this. Using `len` as a condition is more human readable as it clearly expresses
intent. Also, it explicitly prevents edge case bugs where the list in question could be None, e.g.

```
if not some_list:
    # This will get called if the list was None. This can occasionally lead to masked bugs
    pass
```

#### `too-many-ancestors`

TODO: I think we can remove this now.

We use class derivation heavily to share common components amongst tests. In general we agree with
the principal of not having deep class inheritance but for tests we need this. Deep inheritance in
non-test classes will be avoided via good code review standards.

## TODOs in code

Use the format

```
# TODO: Some reminder
```
for documenting TODOs. pylint will detect these.

## Single vs Double Quotes

We take a leaf from Ruby's book here. Since we use a lot of Ruby in house we'll follow the following
convention.

If the string is a format string or has escape characters in then use double quotes, otherwise use
single quotes. For example,

```
str1 = 'Single quotes for me'
str2 = "Double quotes for {}".format('me')
str3 = "Double quotes\n for me as well\n"
```

The one case which is paradoxical is strings with single quotes in them. For example, which of these
is correct:

```
'Can\'t decide what\'s correct'
"Can't decide what's correct"
```

We opt for the latter because it makes it easier to grep for messages you find in the log output.
Specifically, if you saw "Can't decide what's correct" in the log output but used the former version
then a grep for "Can't decide what's correct" would return no results.

# Doc Strings

We follow Google's style guide for doc strings:

http://google.github.io/styleguide/pyguide.html?showone=Comments#Comments

# Git Workflow

## Tickets and branches

We use Jira for project management internally. Roughly speakign there should be one branch per Jira
ticket. The branch name should have the form `#{JIRA_TICKET_NUMBER_UPPER_CASE}`-#{lower case letters
and dashes/underscores describing ticket}, e.g.

```
CSS-1234-add-git-to-coding-standards
```

## Commit Messages

They should have the following format

* Separate subject from body with a blank line
* Limit the subject line to 50 characters
* Capitalize the subject line
* Do not end the subject line with a period
* Use the imperative mood in the subject line
* Wrap the body at 72 characters
* Use the body to explain what and why vs. how
* Commits with only a subject are okay for simple changes

For example:

```
CS-1234 Update the coding guidelines

Add information about git commit message standards in order to ensure
we have a high quality code base.
```

## Merging

Merges to `master` should be done as git squashes. This provides clearer commit history on the
`master` branch. The commit history then looks like a list of implemented tickets as opposed to
a huge list of small commits made on each branch.

# Logging in Python Code

All logging related functionality can be found in the module `xv_leak_tools.log`. Logging uses the
standard python `logging` module. However, we provide some wrapping logic to tailor the logging to
our needs.

The wrapping logic is contained in the `LeakTestLogger` class and all logging should be done via
this. The class can and should be referred to by the alias `L` for brevity.

## Initialization and Configuration

To initialize logging you need the following as a bare minimum

```
from xv_leak_tools.log import L
L.configure()
```

This will initialize the logs with the default config. The default config can be found in the class
attribute `LeakTestLogger.DEFAULT_CONFIG`. You can override the config by passing your own dict to
the `configure` class method.

```
from xv_leak_tools.log import L

L.configure({
    'trace': {
        'level': LeakTestLogger.VERBOSE,
    },
    'report': {
        'logfile': os.path.join('/', 'my', 'custom', 'logfile.txt')
    },
})

LeakTestLogger.initialize()
```

## Loggers and Logging Functions

Under the hood the `LeakTestLogger` class creates four loggers: `instruction, report, describe,
trace`. The `trace` logger also has several log levels available:
`ERROR, WARNING, INFO, DEBUG, VERBOSE`. The other loggers do not have levels.

Note that these loggers are just regular logger objects returned by the `logging` function
`getLogger`.

The purpose of having different loggers is so that output can be sent to different files and
streams. This allows for logical separation of logs corresponding to different types of output.

Each of the loggers can be accessed via helper functions, e.g. `L.info(msg)` outputs a message to
the `trace` logger with level `INFO`.

### `instruction`

This logger is used solely for issuing instructions to the user to prompt for manual input. Some of
the tests either haven't been or can't be fully automated. When user input is required use this
logger, e.g.

```
L.instruction("Please connect to VPN")
```

### `report`

When running a test it is desirable to capture information about the environment in which the test
was run. For example, the OS version, the version and settings of the VPN application or other
applications. This can help with debugging when a test fails. It allows easy sanity checking of the
environment to ensure that a test didn't fail because it ran in the wrong environment.

In general tests don't need to do any `report`ing directly themselves. Usually the underlying
components of the tests will do this automatically. For example, any test deriving from the class
`TestCaseWithOSHelper` will automatically report the OS version it was run on.

```
L.report("Some information about the environment used")
```

### `describe`

Used to describe what the test is doing in human readable steps. Imagine that each line of text
logged by this function is a repro step for a QA engineer. Once a test is run, the lines emitted
by `describe` should be a complete list of repro steps to manually recreate the test scenario.

Think of this as a way of making the tests cases self documenting.

```
L.describe("Connect to VPN")
self.vpn_application.connect()

L.describe("Get the public IPv4 address after VPN connect")
public_ipv4_after_connect = Network.get_public_ipv4_address()

```

> When using the `L.describe` function, prefer not to output dynamic information which is device or
  configuration specific. For example, the message `"Disable the primary interface"` is preferable
  to `"Disabled interface en0"` as it's more generic and applies in all situations.

### `trace`

Used for any other logging which doesn't fit into the previous three categories. Think of this as
like the regular logging in a normal application. Tracing can be done at the usual levels offered
by logging: `ERROR, WARNING, INFO, DEBUG` along with an even more verbose level `VERBOSE`. These
are wrapped by helper functions `error, warn`, `info`, `debug`, `verbose`. N.B. There is no `trace`
function, this is just the name of the logger

In general the rule of thumb is as follows

* `error, warn`: For use when fatal or unexpected behaviour occurs. Don't use these for logging test
  failures. Use assertions to log these. The framework will handle reporting those itself.
* `info`: Any logging which you think should be seen as part of a regular test run. This can come
  from either the tests themselves or from the testing framework.
* `debug`: Prefer to use this just for the testing framework. Think of it as a channel to debug the
  test framework itself.
* `verbose`: Similar to `debug`, but should be used for debugging code which will spew large volumes
  of trace which would make the `debug` output unreadable. For example, if you have parsing code to
  parse lots of lines of packet trace then you might wish to add debugging for the parser. However,
  if the parser needs debugging for every line it parses then this would make the `debug` trace hard
  to read. Instead consider `verbose` in this situation.
